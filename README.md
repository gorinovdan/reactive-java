# reactive-java
Лабораторные работы курса "Реактивная Java"


## Лабораторная работа №1.


Предметная область: "интеграция магазина с банком"

1. Написать для согласованной предметной области как минимум 3 базовых класса и генераторы объектов.
Генератор должен уметь создавать указанное количество различных объектов сответствующего класса со случайными
(но при этом валидными) характеристиками. Класс, представляющий собой массовый объект должен обязательно содержать поля следющих типов:
- один из примитивов (int, long, double)
- String
- дата/время (LocalDate, LocalTime, ...)
- enum
- record
- массив или коллекция
  Остальные поля - произвольные, какие нужны для предметной области.
  Два оставшихся класса должны представлять собой дополнительные атрибуты и характиристики массового класса.

2. С помощью генератора создать коллекцию объектов.
3. Написать код, реализующий расчет согласованных агрегированных статических данных тремя способами:
   3.1. Итерационным циклом по коллекции
   3.2. Конвейером с помощью Stream API на базе коллекторов из стандартной библиотеки
   3.3. Конвейером с помощью собственного коллектора.

4. Для каждого варианта измерить время выполнения, зафиксировав моменты начала и окончания расчета для количества элементов в коллекции - 5000, 50000 и 250000. Время измерять с помощью методов класса System или InstantgetName

## Лабораторная работа №2

Предметная область и генераторы чеков перенесены из ЛР1; далее исследуется производительность расчёта агрегированных метрик.

### Реализация
- `lab2/src/main/java/rj/lab2/model/Item.java` добавляет перегрузку `getName(long delayMillis)`, а `lab2/src/main/java/rj/lab1/util/LatencySimulator.java` реализует имитацию задержки через busy loop и spin-wait вместо `Thread.sleep()`.
- Потокобезопасные накопители собраны в `lab2/src/main/java/rj/lab2/statistics/Collectors/ReceiptStatisticsAccumulator.java` и подключены из `ReceiptStatisticsCollector`/`ReceiptStatisticsStreamAggregator`, что позволяет переключаться между последовательным и параллельным стримами с единым API.
- Для тонкой настройки параллельного конвейера реализован `lab2/src/main/java/rj/lab2/statistics/spliterator/ReceiptSpliterator.java` и обёртка `ReceiptStatisticsSpliteratorAggregator`.
- JMH-бенчмарки находятся в `lab2/src/jmh/java/rj/lab2/benchmarks/ReceiptStatisticsBenchmark.java`, удобный лаунчер описан в `lab2/src/main/java/rj/lab2/benchmarks/JmhRunner.java`, а fat JAR собирает `maven-shade-plugin`.

### Методика измерений
- Базовые замеры (без искусственной задержки) проводились через `lab2/src/main/java/rj/lab2/Main.java`; подробный отчёт хранится в `target/reports/lab2-report-20251006-183831.txt`.
- Сценарий с задержкой 5 мс измерялся отдельным запуском из JShell (см. команды ниже): на выборках 50/75/100 чеков сравнивались последовательный и параллельный стримы.
- Полный прогон JMH выполнялся командой  
  `powershell.exe -NoLogo -Command "java -jar lab2\target\lab2-1.0-SNAPSHOT-benchmarks.jar -wi 2 -i 5 -f 1 -rf csv -rff target\reports\lab2-jmh-results.csv ReceiptStatisticsBenchmark"`.  
  Из-за длительных задержек зафиксированы частичные результаты (консольный вывод сохранён вручную; CSV пока пуст).

### Результаты без искусственной задержки

| Объём чеков | Итеративный цикл | parallelStream | parallelStream + Spliterator | Лучший подход |
| --- | --- | --- | --- | --- |
| 5,000 | 0.345 s | 0.467 s (+35%) | 0.157 s (-55%) | Spliterator |
| 50,000 | 1.636 s | 2.119 s (+30%) | 1.796 s (+10%) | Итеративный цикл |
| 250,000 | 8.166 s | 10.006 s (+23%) | 12.039 s (+48%) | Итеративный цикл |

Значения получены в одном JVM-процессе с генерацией свежих данных перед каждым замером. Для 5 тыс. чеков кастомный `Spliterator` даёт 2.2× ускорение за счёт более крупных чанков, однако на крупных наборах балансировка приводит к недозагрузке потоков и деградации до +48% к последовательной версии.

### Порог при задержке 5 мс на получение имени товара

| Объём чеков | Последовательный стрим | Параллельный стрим | Ускорение |
| --- | --- | --- | --- |
| 50 | 1.204 s | 0.188 s | 6.42x |
| 75 | 1.696 s | 0.136 s | 12.48x |
| 100 | 2.250 s | 0.201 s | 11.21x |

Даже на 50 чеках параллельный конвейер быстрее более чем в 6 раз. Линейная аппроксимация (0.024 s на чек в последовательном режиме) даёт точку равной скорости около 8 чеков: при меньших выборках смысла в параллелизме нет, но практически все рабочие объёмы лежат правее этой границы.

### JMH: частичный прогон

| datasetSize | delay = 0 ms, avg ms/op | 99.9% CI (± ms) | Комментарий |
| --- | --- | --- | --- |
| 1,000 | 10.652 | 3.098 | стабильный прогрев |
| 5,000 | 57.905 | 12.970 | разброс из-за аллокаций в `ConcurrentHashMap` |
| 20,000 | 340.023 | 90.107 | снижение после прогрева (распределение нагрузки) |
| 50,000 | 1,470.457 | 230.966 | заметна пауза GC на 4-й итерации |
| 100,000 | 2,930.726 | 249.308 | дальнейший рост почти линейный |

| datasetSize | delay = 5 ms, avg ms/op | 99.9% CI (± ms) | Комментарий |
| --- | --- | --- | --- |
| 1,000 | 1,700.128 | 38.971 | ожидания доминируют, параллельность окупается |
| 5,000 | 8,330.402 | 349.466 | латентность полностью скрывается CPU |
| 20,000 | 35,506.092 | 22,531.163 | выброс на 5-й итерации (45950 ms) |
| 50,000 | 82,104.690 | 2,882.966 | стабильно, но долго (~82 s на замер) |
| 100,000 | - | - | прогон прерван из-за времени выполнения |

Для долгих прогонов следует уменьшать задержку или число итераций, иначе CSV не заполняется до завершения бенчмарка.

### Выводы
- Без искусственной задержки накладные расходы `parallelStream()` и `ConcurrentHashMap` делают последовательную реализацию быстрее вплоть до 250k чеков; польза кастомного `Spliterator` ограничивается малыми наборами.
- При задержке 5 мс параллельный конвейер выигрывает уже с ~8 чеков и масштабируется пропорционально числу доступных потоков.
- Частичные результаты JMH подтверждают тренд, но демонстрируют чувствительность к outlier'ам; перед полноценной публикацией стоит собрать дополнительные форки и/или снизить длительность итераций.

### Скрипт полного запуска
Для автоматизации есть `lab2/run-lab2.bat`, который по шагам:
1. собирает проект и тени-бандл,
2. запускает демо-отчёт (`Main`),
3. выполняет JMH-бенчмарки (можно прервать, если нужны выборочные прогоны).
   Во время шага 2 автоматически сохраняется подробный отчёт со всеми метриками (`target/reports/lab2-report-*.txt`).

При необходимости собственных измерений запускайте:
```bat
java -jar target\lab2-1.0-SNAPSHOT-benchmarks.jar ^
     -wi 3 -i 5 -f 1 ^
     -p datasetSize=5000 -p itemNameDelayMillis=5 ^
     ReceiptStatisticsBenchmark
```
и варьируйте параметры `datasetSize`/`itemNameDelayMillis`, чтобы найти пороговые значения производительности.

## Лабораторная работа №3

1. Реализовать подсчет статистики, аналогичный использованному в лабораторной работе №2, с помощью реактивных потоков 
Observable на RxJava. Должна обеспечиваться многопоточная асинхронная обработка с использованием Scheduler.

2. Провести сравнение производительности обработки 500 и 2000 элементов с включенной задержкой для параллельных потоков 
(из лабы 2) и для реактивных потоков. Необходимо добиться, чтобы производительность реактивных потоков была такой же или лучше, 
чем при использовании параллельных потоков.

3. Отключить задержку при создании элементов. Реализовать собственный Subscriber для подсчета статистики, регулирующий 
скорость поступления элементов из потока. Генерацию элементов с поддержкой backpressure производить асинхронно с помощью Flowable. 
Убедиться, что при большом количестве элементов (больше 100000) система работает стабильно и без задержек.
