# reactive-java
Лабораторные работы курса "Реактивная Java"


## Лабораторная работа №1.


Предметная область: "интеграция магазина с банком"

1. Написать для согласованной предметной области как минимум 3 базовых класса и генераторы объектов.
Генератор должен уметь создавать указанное количество различных объектов сответствующего класса со случайными
(но при этом валидными) характеристиками. Класс, представляющий собой массовый объект должен обязательно содержать поля следющих типов:
- один из примитивов (int, long, double)
- String
- дата/время (LocalDate, LocalTime, ...)
- enum
- record
- массив или коллекция
  Остальные поля - произвольные, какие нужны для предметной области.
  Два оставшихся класса должны представлять собой дополнительные атрибуты и характиристики массового класса.

2. С помощью генератора создать коллекцию объектов.
3. Написать код, реализующий расчет согласованных агрегированных статических данных тремя способами:
   3.1. Итерационным циклом по коллекции
   3.2. Конвейером с помощью Stream API на базе коллекторов из стандартной библиотеки
   3.3. Конвейером с помощью собственного коллектора.

4. Для каждого варианта измерить время выполнения, зафиксировав моменты начала и окончания расчета для количества элементов в коллекции - 5000, 50000 и 250000. Время измерять с помощью методов класса System или Instant

## Лабораторная работа №2

Предметная область и исходные генераторы чеков перенесены из первой лабораторной. Цель текущей работы — исследовать и оптимизировать конвейер расчёта агрегированных статистик.

### Задача 1. Имитация задержек
- Метод `Item#getName()` расширен перегрузкой `getName(long delayMillis)`, позволяющей эмулировать задержку, например при обращении к базе данных.
- Все сборщики статистики теперь принимают параметр задержки и прокидывают его в бизнес-логику.

### Задача 2. Параллельное агрегирование
- Потоки, которые в ЛР1 были последовательными, заменены на `parallelStream()`.
- Все промежуточные коллекции и множества в `ReceiptStatisticsAccumulator` переведены на потокобезопасные реализации (`ConcurrentHashMap`, `ConcurrentHashMap.newKeySet()`).
- Проведены измерения производительности для разных объёмов входных данных и для сценариев с задержкой/без задержки. Отдельно фиксируются точки, где производительность последовательного и параллельного исполнения совпадает.

### Задача 3. Кастомный `Spliterator`
- Реализован `ReceiptSpliterator`, оптимизирующий разбиение списка чеков на батчи. Он задействован в `ReceiptStatisticsSpliteratorAggregator`, что позволяет сравнить «штатный» параллельный стрим и вариант с тонкой настройкой.

### Задача 4. Замеры через JMH
- Добавлен модуль бенчмарков (`src/jmh/java`) и класс `ReceiptStatisticsBenchmark`, в котором сравниваются:
  1. последовательный стрим,
  2. параллельный стрим,
  3. параллельный стрим с кастомным `Spliterator`.
- В параметрах `@Param` задан ряд размеров выборки и величина искусственной задержки.
- Конфигурация Maven дополняется зависимостями JMH и `maven-shade-plugin`, чтобы собирать runnable JAR (`lab2-1.0-SNAPSHOT-benchmarks.jar`). Для удобства запусков добавлен `rj.lab2.benchmarks.JmhRunner`.

### Скрипт полного запуска
Для автоматизации есть `lab2/run-lab2.bat`, который по шагам:
1. собирает проект и тени-бандл,
2. запускает демо-отчёт (`Main`),
3. выполняет JMH-бенчмарки (можно прервать, если нужны выборочные прогоны).
   Во время шага 2 автоматически сохраняется подробный отчёт со всеми метриками (`target/reports/lab2-report-*.txt`).

При необходимости собственных измерений запускайте:
```bat
java -jar target\lab2-1.0-SNAPSHOT-benchmarks.jar ^
     -wi 3 -i 5 -f 1 ^
     -p datasetSize=5000 -p itemNameDelayMillis=5 ^
     ReceiptStatisticsBenchmark
```
и варьируйте параметры `datasetSize`/`itemNameDelayMillis`, чтобы найти пороговые значения производительности.
